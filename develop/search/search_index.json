{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Simple TOML Configurator","text":"<p>The Simple TOML Configurator is a versatile Python library designed to streamline the handling and organization of configuration settings across various types of applications. This library facilitates the management of configuration values through a user-friendly interface and stores these settings in TOML file format for easy readability and accessibility.</p>"},{"location":"#documentation","title":"Documentation","text":"<p>https://gilbn.github.io/Simple-TOML-Configurator/</p>"},{"location":"#features","title":"Features","text":"<ol> <li> <p>Effortless Configuration Management: The heart of the library is the <code>Configuration</code> class, which simplifies the management of configuration settings. It provides intuitive methods to load, update, and store configurations, ensuring a smooth experience for developers.</p> </li> <li> <p>Universal Applicability: The Simple TOML Configurator is designed to work seamlessly with any type of Python application, ranging from web frameworks like Flask, Django, and FastAPI to standalone scripts and command-line utilities.</p> </li> <li> <p>TOML File Storage: Configuration settings are stored in TOML files, a popular human-readable format. This enables developers to review, modify, and track configuration changes easily.</p> </li> <li> <p>Attribute-Based Access: Accessing configuration values is straightforward, thanks to the attribute-based approach. Settings can be accessed and updated as attributes, making it convenient for both reading and modifying values.</p> </li> <li> <p>Environment Variable Support: Configuration values are automatically set as environment variables, making it easier to use the configuration values in your application. Environment variable are set as uppercase. e.g. <code>APP_HOST</code> and <code>APP_PORT</code> or <code>PROJECT_APP_HOST</code> and <code>PROJECT_APP_PORT</code> if <code>env_prefix</code> is set to \"project\". This also works for nested values. ex: <code>TABLE_KEY_LEVEL1_KEY_LEVEL2_KEY</code>. This works for any level of nesting.Environment variables set before the configuration is loaded will not be overwritten, but instead will overwrite the existing config value.</p> </li> <li> <p>Default Values: Developers can define default values for various configuration sections and keys. The library automatically incorporates new values and manages the removal of outdated ones.</p> </li> <li> <p>Customization Capabilities: The <code>Configuration</code> class can be extended and customized to cater to application-specific requirements. Developers can implement custom logic with getters and setters to handle unique settings or scenarios.</p> </li> </ol>"},{"location":"#installation","title":"Installation","text":"<p>Install with <pre><code>pip install simple-toml-configurator\n</code></pre></p>"},{"location":"#usage-example","title":"Usage Example","text":"<p>See Usage for more examples.</p> <pre><code>import os\nfrom simple_toml_configurator import Configuration\n\n# Define default configuration values\ndefault_config = {\n    \"app\": {\n        \"ip\": \"0.0.0.0\",\n        \"host\": \"\",\n        \"port\": 5000,\n        \"upload_folder\": \"uploads\",\n    },\n    \"mysql\": {\n        \"user\": \"root\",\n        \"password\": \"root\",\n        \"databases\": {\n            \"prod\": \"db1\",\n            \"dev\": \"db2\",\n            },\n    }\n}\n\n# Set environment variables\nos.environ[\"PROJECT_APP_UPLOAD_FOLDER\"] = \"overridden_uploads\"\n\n# Initialize the Simple TOML Configurator\nsettings = Configuration(config_path=\"config\", defaults=default_config, config_file_name=\"app_config\", env_prefix=\"project\")\n# Creates an `app_config.toml` file in the `config` folder at the current working directory.\n\n# Access and update configuration values\nprint(settings.app.ip)  # Output: '0.0.0.0'\nsettings.app.ip = \"1.2.3.4\"\nsettings.update()\nprint(settings.app_ip)  # Output: '1.2.3.4'\n\n# Access nested configuration values\nprint(settings.mysql.databases.prod)  # Output: 'db1'\nsettings.mysql.databases.prod = 'new_value'\nsettings.update()\nprint(settings.mysql.databases.prod)  # Output: 'new_value'\n\n# Access and update configuration values\nprint(settings.app_ip)  # Output: '1.2.3.4'\nsettings.update_config({\"app_ip\": \"1.1.1.1\"})\nprint(settings.app_ip)  # Output: '1.1.1.1'\n\n# Access all settings as a dictionary\nall_settings = settings.get_settings()\nprint(all_settings)\n# Output: {'app_ip': '1.1.1.1', 'app_host': '', 'app_port': 5000, 'app_upload_folder': 'overridden_uploads', 'mysql_user': 'root', 'mysql_password': 'root', 'mysql_databases': {'prod': 'new_value', 'dev': 'db2'}}\n\n# Modify values directly in the config dictionary\nsettings.config[\"mysql\"][\"databases\"][\"prod\"] = \"db3\"\nsettings.update()\nprint(settings.mysql_databases[\"prod\"])  # Output: 'db3'\n\n# Access environment variables\nprint(os.environ[\"PROJECT_MYSQL_DATABASES_PROD\"])  # Output: 'db3'\nprint(os.environ[\"PROJECT_APP_UPLOAD_FOLDER\"])  # Output: 'overridden_uploads'\n</code></pre> <p><code>app_config.toml</code> contents</p> <pre><code>[app]\nip = \"1.1.1.1\"\nhost = \"\"\nport = 5000\nupload_folder = \"overridden_uploads\"\n\n[mysql]\nuser = \"root\"\npassword = \"root\"\n\n[mysql.databases]\nprod = \"db3\"\ndev = \"db2\"\n</code></pre>"},{"location":"configurator/","title":"Simple TOML Configurator Docs","text":""},{"location":"configurator/#src.simple_toml_configurator.toml_configurator.ConfigObject","title":"<code>ConfigObject</code>","text":"<p>Represents a configuration object that wraps a dictionary and provides attribute access.</p> <p>Any key in the dictionary can be accessed as an attribute.</p> <p>Parameters:</p> Name Type Description Default <code>table</code> <code>dict</code> <p>The dictionary representing the configuration.</p> required <p>Attributes:</p> Name Type Description <code>_table</code> <code>dict</code> <p>The internal dictionary representing the configuration.</p> Source code in <code>src/simple_toml_configurator/toml_configurator.py</code> <pre><code>class ConfigObject:\n    \"\"\"\n    Represents a configuration object that wraps a dictionary and provides attribute access.\n\n    Any key in the dictionary can be accessed as an attribute.\n\n    Args:\n        table (dict): The dictionary representing the configuration.\n\n    Attributes:\n        _table (dict): The internal dictionary representing the configuration.\n\n    \"\"\"\n\n    def __init__(self, table: dict):\n        self._table = table\n        for key, value in table.items():\n            if isinstance(value, dict):\n                self.__dict__[key] = ConfigObject(value)\n            else:\n                self.__dict__[key] = value\n\n    def __setattr__(self, __name: str, __value: Any) -&gt; None:\n        \"\"\"Update the table value when an attribute is set\"\"\"\n        super().__setattr__(__name, __value)\n        if __name == \"_table\":\n            return\n        if hasattr(self, \"_table\") and __name in self._table:\n            self._table[__name] = __value\n\n    def __repr__(self) -&gt; str:\n        return f\"ConfigObject({self._table})\"\n\n    def __str__(self) -&gt; str:\n        return f\"&lt;ConfigObject&gt; {self._table}\"\n</code></pre>"},{"location":"configurator/#src.simple_toml_configurator.toml_configurator.ConfigObject.__setattr__","title":"<code>__setattr__(__name, __value)</code>","text":"<p>Update the table value when an attribute is set</p> Source code in <code>src/simple_toml_configurator/toml_configurator.py</code> <pre><code>def __setattr__(self, __name: str, __value: Any) -&gt; None:\n    \"\"\"Update the table value when an attribute is set\"\"\"\n    super().__setattr__(__name, __value)\n    if __name == \"_table\":\n        return\n    if hasattr(self, \"_table\") and __name in self._table:\n        self._table[__name] = __value\n</code></pre>"},{"location":"configurator/#src.simple_toml_configurator.toml_configurator.Configuration","title":"<code>Configuration</code>","text":"<p>Class to set our configuration values we can use around in our app. The configuration is stored in a toml file as well as on the instance.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; default_config = {\n    \"app\": {\n        \"ip\": \"0.0.0.0\",\n        \"host\": \"\",\n        \"port\": 5000,\n        \"upload_folder\": \"uploads\"\n        }\n    }\n&gt;&gt;&gt; import os\n&gt;&gt;&gt; from simple_toml_configurator import Configuration\n&gt;&gt;&gt; settings = Configuration(\"config\", default_config, \"app_config\")\n{'app': {'ip': '0.0.0.0', 'host': '', 'port': 5000, 'upload_folder': 'uploads'}}\n# Update the config dict directly\n&gt;&gt;&gt; settings.app.ip = \"1.1.1.1\"\n&gt;&gt;&gt; settings.update()\n&gt;&gt;&gt; settings.app.ip\n'1.1.1.1'\n&gt;&gt;&gt; settings.get_settings()\n{'app_ip': '1.1.1.1', 'app_host': '', 'app_port': 5000, 'app_upload_folder': 'uploads'}\n&gt;&gt;&gt; settings.update_config({\"app_ip\":\"1.2.3.4\"})\n&gt;&gt;&gt; settings.app_ip\n'1.2.3.4'\n&gt;&gt;&gt; settings.config.get(\"app\").get(\"ip\")\n'1.2.3.4'\n&gt;&gt;&gt; settings.config[\"app\"][\"ip\"] = \"0.0.0.0\"\n&gt;&gt;&gt; settings.update()\n&gt;&gt;&gt; settings.app_ip\n'0.0.0.0'\n&gt;&gt;&gt; print(os.environ.get(\"APP_UPLOAD_FOLDER\"))\n'uploads'\n</code></pre> <p>Attributes:</p> Name Type Description <code>config</code> <code>TOMLDocument</code> <p>TOMLDocument with all config values</p> <code>config_path</code> <code>str | Path</code> <p>Path to config folder</p> <code>config_file_name</code> <code>str</code> <p>Name of the config file</p> <code>defaults</code> <code>dict[str, dict]</code> <p>Dictionary with all default values for your application</p> <p>Info</p> <p>Changing a table name in your <code>defaults</code> will remove the old table in config including all keys and values.</p> <p>Note</p> <p>If updating an attribute needs extra logic, make a custom class that inherits from this class and add property attributes with a getter and setter.</p> <p>Example:</p> <pre><code>from simple_toml_configurator import Configuration\nfrom utils import configure_logging\n\nclass CustomConfiguration(Configuration):\n    def __init__(self):\n        super().__init__()\n\n    @property\n    def logging_debug(self):\n        return getattr(self, \"_logging_debug\")\n\n    @logging_debug.setter\n    def logging_debug(self, value: bool):\n        if not isinstance(value, bool):\n            raise ValueError(f\"value must be of type bool not {type(value)}\")\n        self._logging_debug = value\n        log_level = \"DEBUG\" if value else \"INFO\"\n        configure_logging(log_level)\n        logger.debug(f\"Debug logging set to {value}\")\n\n    defaults = {\n        \"logging\": {\n            \"debug\": False\n        ...\n        }\n\n    config_path = os.environ.get(\"CONFIG_PATH\", \"config\")\n    settings = CustomConfiguration()\n    settings.init_config(config_path, defaults, \"app_config\"))\n</code></pre> Source code in <code>src/simple_toml_configurator/toml_configurator.py</code> <pre><code>class Configuration:\n    \"\"\"Class to set our configuration values we can use around in our app.\n    The configuration is stored in a toml file as well as on the instance.\n\n    Examples:\n        ```pycon\n        &gt;&gt;&gt; default_config = {\n            \"app\": {\n                \"ip\": \"0.0.0.0\",\n                \"host\": \"\",\n                \"port\": 5000,\n                \"upload_folder\": \"uploads\"\n                }\n            }\n        &gt;&gt;&gt; import os\n        &gt;&gt;&gt; from simple_toml_configurator import Configuration\n        &gt;&gt;&gt; settings = Configuration(\"config\", default_config, \"app_config\")\n        {'app': {'ip': '0.0.0.0', 'host': '', 'port': 5000, 'upload_folder': 'uploads'}}\n        # Update the config dict directly\n        &gt;&gt;&gt; settings.app.ip = \"1.1.1.1\"\n        &gt;&gt;&gt; settings.update()\n        &gt;&gt;&gt; settings.app.ip\n        '1.1.1.1'\n        &gt;&gt;&gt; settings.get_settings()\n        {'app_ip': '1.1.1.1', 'app_host': '', 'app_port': 5000, 'app_upload_folder': 'uploads'}\n        &gt;&gt;&gt; settings.update_config({\"app_ip\":\"1.2.3.4\"})\n        &gt;&gt;&gt; settings.app_ip\n        '1.2.3.4'\n        &gt;&gt;&gt; settings.config.get(\"app\").get(\"ip\")\n        '1.2.3.4'\n        &gt;&gt;&gt; settings.config[\"app\"][\"ip\"] = \"0.0.0.0\"\n        &gt;&gt;&gt; settings.update()\n        &gt;&gt;&gt; settings.app_ip\n        '0.0.0.0'\n        &gt;&gt;&gt; print(os.environ.get(\"APP_UPLOAD_FOLDER\"))\n        'uploads'\n        ```\n\n    Attributes:\n        config (TOMLDocument): TOMLDocument with all config values\n        config_path (str|Path): Path to config folder\n        config_file_name (str): Name of the config file\n        defaults (dict[str,dict]): Dictionary with all default values for your application\n\n    !!! Info\n        Changing a table name in your `defaults` will remove the old table in config including all keys and values.\n\n    !!! Note\n        If updating an attribute needs extra logic, make a custom class that inherits from this class and add property attributes with a getter and setter.\n\n        Example:\n\n        ```python\n        from simple_toml_configurator import Configuration\n        from utils import configure_logging\n\n        class CustomConfiguration(Configuration):\n            def __init__(self):\n                super().__init__()\n\n            @property\n            def logging_debug(self):\n                return getattr(self, \"_logging_debug\")\n\n            @logging_debug.setter\n            def logging_debug(self, value: bool):\n                if not isinstance(value, bool):\n                    raise ValueError(f\"value must be of type bool not {type(value)}\")\n                self._logging_debug = value\n                log_level = \"DEBUG\" if value else \"INFO\"\n                configure_logging(log_level)\n                logger.debug(f\"Debug logging set to {value}\")\n\n            defaults = {\n                \"logging\": {\n                    \"debug\": False\n                ...\n                }\n\n            config_path = os.environ.get(\"CONFIG_PATH\", \"config\")\n            settings = CustomConfiguration()\n            settings.init_config(config_path, defaults, \"app_config\"))\n        ```\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -&gt; None:\n        self.logger = logging.getLogger(\"Configuration\")\n        if args or kwargs:\n            self.init_config(*args, **kwargs)\n\n    def __repr__(self) -&gt; str:\n        return f\"Configuration(config_path={getattr(self,'config_path', None)}, defaults={getattr(self, 'defaults',None)}, config_file_name={getattr(self, 'config_file_name', None)})\" # pragma: no cover\n\n    def __str__(self) -&gt; str:\n        return f\"&lt;Configuration&gt; File:'{getattr(self, 'config_file_name', None)}' Path:'{getattr(self, '_full_config_path', None)}'\" # pragma: no cover\n\n    def init_config(self, config_path:str|Path, defaults:dict[str,dict], config_file_name:str=\"config\",env_prefix:str=\"\") -&gt; TOMLDocument:\n        \"\"\"\n        Creates the config folder and toml file if needed.\n\n        Upon init it will add any new/missing values/tables from `defaults` into the existing TOML config.\n        Removes any old values/tables from `self.config` that are not in `self.defaults`.\n\n        Sets all config keys as attributes on the class. e.g. `self.table.key`, `self.table_key` and `self._table_key`\n\n        Env variables of all config keys are set as uppercase. e.g. `APP_HOST` and `APP_PORT` or `APP_CONFIG_APP_HOST` and `APP_CONFIG_APP_PORT` if `env_prefix` is set to \"app_config\".\n\n        Nested tables are set as nested environment variables. e.g. `APP_CONFIG_APP_DATABASES_PROD` and `APP_CONFIG_APP_DATABASES_DEV`.\n\n        Examples:\n            ```pycon\n            &gt;&gt;&gt; settings = Configuration()\n            &gt;&gt;&gt; settings.init_config(\"config\", defaults, \"app_config\"))\n            ```\n\n        Args:\n            config_path (str|Path): Path to config folder\n            defaults (dict[str,dict]): Dictionary with all default values for your application\n            config_file_name (str, optional): Name of the config file. Defaults to \"config\".\n            env_prefix (str, optional): Prefix for environment variables. Defaults to \"\".\n\n        Returns:\n            dict[str,Any]: Returns a TOMLDocument.\n        \"\"\"\n\n        if not isinstance(config_path, (str, Path)):\n            raise TypeError(f\"argument config_path must be of type {type(str)} or {type(Path)}, not: {type(config_path)}\") # pragma: no cover\n        if not isinstance(defaults, dict):\n            raise TypeError(f\"argument defaults must be of type {type(dict)}, not: {type(defaults)}\") # pragma: no cover\n        if not isinstance(env_prefix, str):\n            raise TypeError(f\"argument env_prefix must be of type {type(str)}, not: {type(env_prefix)}\") # pragma: no cover\n        if not isinstance(config_file_name, str):\n            raise TypeError(f\"argument config_file_name must be of type {type(str)}, not: {type(config_file_name)}\") # pragma: no cover\n\n        self.defaults:dict[str,dict] = defaults\n        self.config_path:str|Path = config_path\n        self.config_file_name:str = f\"{config_file_name}.toml\"\n        self.env_prefix:str = env_prefix\n        self._full_config_path:str = os.path.join(self.config_path, self.config_file_name)\n        self.config:TOMLDocument = self._load_config()\n        self._sync_config_values()\n        self._set_os_env()\n        self._set_attributes()\n        return self.config\n\n    def _sync_config_values(self) -&gt; None:\n        \"\"\"Add any new/missing values/tables from self.defaults into the existing TOML config\n        - If a table is missing from the config, it will be added with the default table.\n        - If a table is missing from the defaults, it will be removed from the config.\n        If there is a mismatch in types between the default value and the config value, the config value will be replaced with the default value.\n\n        For example if the default value is a string and the existing config value is a dictionary, the config value will be replaced with the default value.\n        \"\"\"\n        def update_dict(current_dict:dict, default_dict:dict) -&gt; dict:\n            \"\"\"Recursively update a dictionary with another dictionary.\n\n            Args:\n                current_dict (dict): The dictionary to update. Loaded from the config file.\n                default_dict (dict): The dictionary to update with. Loaded from the defaults.\n\n            Returns:\n                dict: The updated dictionary\n            \"\"\"\n            for key, value in default_dict.items():\n                if isinstance(value, Mapping):\n                    if not isinstance(current_dict.get(key, {}), Mapping):\n                        logger.warning(\"Mismatched types for key '%s': expected dictionary, got %s. Replacing with new dictionary.\", key, type(current_dict.get(key))) # pragma: no cover\n                        current_dict[key] = {}\n                    if key not in current_dict:\n                        logger.info(\"Adding new Table: ('%s')\", key) # pragma: no cover\n                    current_dict[key] = update_dict(current_dict.get(key, {}), value)\n                else:\n                    if key not in current_dict:\n                        logger.info(\"Adding new Key: ('%s':'***') in table: %s\", key, current_dict) # pragma: no cover\n                        current_dict[key] = value\n            return current_dict\n\n        self.config = update_dict(self.config, self.defaults)\n        self._write_config_to_file()\n        self._clear_old_config_values()\n\n    def _clear_old_config_values(self) -&gt; None:\n        \"\"\"Remove any old values/tables from self.config that are not in self.defaults\n        \"\"\"\n        def remove_keys(config:dict, defaults:dict) -&gt; None:\n            # Create a copy of config to iterate over\n            config_copy = config.copy()\n\n            # Remove keys that are in config but not in defaults\n            for key in config_copy:\n                if key not in defaults:\n                    del config[key]\n                    logger.info(\"Removing Key: ('%s') in Table: ( '%s' )\", key, config_copy)\n                elif isinstance(config[key], Mapping):\n                    remove_keys(config[key], defaults[key])\n\n        remove_keys(self.config, self.defaults)\n        self._write_config_to_file()\n\n    def get_settings(self) -&gt; dict[str, Any]:\n        \"\"\"Get all config key values as a dictionary.\n\n        Dict keys are formatted as: `table_key`:\n\n        Examples:\n            ```pycon\n            &gt;&gt;&gt; defaults = {...}\n            &gt;&gt;&gt; settings = Configuration()\n            &gt;&gt;&gt; settings.init_config(\"config\", defaults, \"app_config\"))\n            &gt;&gt;&gt; settings.get_settings()\n            {'app_ip': '0.0.0.0', 'app_host': '', 'app_port': 5000, 'app_upload_folder': 'uploads'}\n            ```\n\n        Returns:\n            dict[str, Any]: Dictionary with config key values.\n        \"\"\"\n        settings: dict[str, Any] = {}\n        for table in self.config:\n            for key, value in self.config[table].items():\n                settings[f\"{table}_{key}\"] = value\n        return settings\n\n    def _set_attributes(self) -&gt; dict[str, Any]:\n        \"\"\"Set all config keys as attributes on the class.\n\n        Two different attributes are set for each key.\n        _TOMLtable_key: e.g. `_app_host`\n        TOMLtable_key: e.g. `app_host`\n\n        This makes it so that the instance attributes are updated when the a value in self.config is updated as they reference the same object.\n\n        Returns:\n            dict[str, Any]: Returns all attributes in a dictionary\n        \"\"\"\n        for table in self.config:\n            setattr(self,table,ConfigObject(self.config[table]))\n            for key, value in self.config[table].items():\n                setattr(self, f\"_{table}_{key}\", value)\n                setattr(self, f\"{table}_{key}\", value)\n                self._update_os_env(table, key, value)\n\n    def _parse_env_value(self, value:str) -&gt; Any:\n        \"\"\"Parse the environment variable value to the correct type.\n\n        Args:\n            value (str): The value to parse\n\n        Returns:\n            Any: The parsed value as the correct type or the original value if it could not be parsed.\n        \"\"\"\n        if str(value).lower() == \"true\":\n            return True\n        if str(value).lower() == \"false\":\n            return False\n        try:\n            parsed_value = ast.literal_eval(value)\n            if isinstance(parsed_value, (int, float, bool, str, list, dict)):\n                return parsed_value\n        except (ValueError, SyntaxError):\n            pass\n        try:\n            return parse(value)\n        except ParserError:\n            pass\n        return str(value)\n\n    def _make_env_name(self, table:str, key:str) -&gt; str:\n        \"\"\"Create an environment variable name from the table and key.\n\n        Args:\n            table (str): The table name\n            key (str): The key name\n\n        Returns:\n            str: The environment variable name\n        \"\"\"\n        if self.env_prefix:\n            return f\"{self.env_prefix.upper()}_{table.upper()}_{str(key).upper()}\"\n        return f\"{table.upper()}_{str(key).upper()}\"\n\n    def _update_os_env(self, table:str, key:str, value:Any) -&gt; None:\n        \"\"\"Update the os environment variable with the same name as the config table and key.\n\n        If the value is a dictionary, creates an environment variable for each item in the dictionary,\n        handling nested dictionaries recursively.\n\n        Args:\n            table (str): The table name\n            key (str): The key name\n            value (Any): The value\n        \"\"\"\n        if isinstance(value, dict):\n            for subkey, subvalue in value.items():\n                self._update_os_env(table, f\"{key}_{subkey}\", subvalue)\n        else:\n            env_var = self._make_env_name(table, key)\n            os.environ[env_var] = str(value)\n\n    def _set_os_env(self) -&gt; None:\n        \"\"\"Set all config keys as environment variables.\n\n        The environment variable is set as uppercase. e.g. `APP_HOST` and `APP_PORT` or `APP_CONFIG_APP_HOST` and `APP_CONFIG_APP_PORT` if `env_prefix` is set to \"app_config\".\n\n        If the environment variable already exists, the config value is updated to the env value and will overwrite any config value.\n        \"\"\"\n        for table in self.config.copy():\n            for key, value in self.config[table].items():\n                existing_env = os.environ.get(self._make_env_name(table, key))\n                if existing_env:\n                    logger.info(\"Setting Table: ('%s') Key: ('%s') to value from existing environment variable: ('%s')\",table, key, existing_env)\n                    self.config[table][key] = self._parse_env_value(existing_env)\n                    continue\n                self._update_os_env(table, key, value)\n        self._write_config_to_file()\n\n    def update_config(self, settings: dict[str,Any]) -&gt; None:\n        \"\"\"Update all config values from a dictionary, set new attribute values and write the config to file.\n        Use the same format as `self.get_settings()` returns to update the config.\n\n        Examples:\n        ```pycon\n        &gt;&gt;&gt; defaults = {\"mysql\": {\"databases\": {\"prod\":\"prod_db1\", \"dev\":\"dev_db1\"}}}\n        &gt;&gt;&gt; settings = Configuration()\n        &gt;&gt;&gt; settings.init_config(\"config\", defaults, \"app_config\")\n        &gt;&gt;&gt; settings.update_config({\"mysql_databases\": {\"prod\":\"prod_db1\", \"dev\":\"dev_db2\"}})\n        print(settings.mysql_databases[\"dev\"])\n        'dev_db2'\n        ```\n\n        Args:\n            settings (dict): Dict with key values\n        \"\"\"\n        if not isinstance(settings, dict):\n            raise TypeError(f\"Argument settings must be of type {type(dict)}, not: {type(settings)}\") # pragma: no cover\n        try:\n            for table in self.config:\n                for key, value in settings.items():\n                    table_key = key.split(f\"{table}_\")[-1]\n                    if self.config.get(table) and table_key in self.config[table].keys():\n                        if self.config[table][table_key] != value:\n                            self.logger.info(\"Updating TOML Document -&gt; Table: ('%s') Key: ('%s')\",table, table_key)\n                            self.config[table][table_key] = value\n        except Exception as exc: # pragma: no cover\n            self.logger.exception(\"Could not update config!\")\n            raise TOMLConfigUpdateError(\"unable to update config!\") from exc\n        self._write_config_to_file()\n        self._set_attributes()\n\n    def update(self):\n        \"\"\"Write the current config to file.\n\n        Examples:\n        ```pycon\n        &gt;&gt;&gt; from simple_toml_configurator import Configuration\n        &gt;&gt;&gt; settings = Configuration()\n        &gt;&gt;&gt; defaults = {\"mysql\": {\"databases\": {\"prod\":\"prod_db1\", \"dev\":\"dev_db1\"}}}\n        &gt;&gt;&gt; settings.init_config(\"config\", defaults, \"app_config\")\n        &gt;&gt;&gt; settings.mysql.databases.prod = \"prod_db2\"\n        &gt;&gt;&gt; settings.update()\n        &gt;&gt;&gt; settings.config[\"mysql\"][\"databases\"][\"prod\"]\n        'prod_db2'\n        &gt;&gt;&gt; settings.config[\"mysql\"][\"databases\"][\"prod\"] = \"prod_db3\"\n        &gt;&gt;&gt; settings.update()\n        &gt;&gt;&gt; settings.mysql_databases[\"prod\"]\n        'prod_db3'\n        ```\n        \"\"\"\n        self._write_config_to_file()\n        self._set_attributes()\n\n    def _write_config_to_file(self) -&gt; None:\n        \"\"\"Update and write the config to file\"\"\"\n        self.logger.debug(\"Writing config to file\")\n        try:\n            with Path(self._full_config_path).open(\"w\") as conf:\n                toml_document = tomlkit.dumps(self.config)\n                # Use regular expression to replace consecutive empty lines with a single newline\n                cleaned_toml = re.sub(r'\\n{3,}', '\\n\\n', toml_document)\n                conf.write(cleaned_toml)\n        except (OSError,FileNotFoundError,TypeError) as exc: # pragma: no cover\n            self.logger.exception(\"Could not write config file!\")\n            raise TOMLWriteConfigError(\"unable to write config file!\") from exc # pragma: no cover\n        self.config = self._load_config()\n\n    def _load_config(self) -&gt; TOMLDocument:\n        \"\"\"Load the config from file and return it as a TOMLDocument\"\"\"\n        try:\n            return tomlkit.loads(Path(self._full_config_path).read_text())\n        except FileNotFoundError: # pragma: no cover\n            self._create_config(self._full_config_path) # Create the config folder and toml file if needed.\n            try:\n                return tomlkit.loads(Path(self._full_config_path).read_text())\n            except Exception as exc:\n                self.logger.exception(\"Could not load config file!\")\n                raise TOMLLoadConfigError(\"unable to load config file!\") from exc\n\n    def _create_config(self, config_file_path:str) -&gt; None:\n        \"\"\"Create the config folder and toml file.\n\n        Args:\n            config_file_path (str): Path to the config file\n        \"\"\"\n\n        # Check if config path exists\n        try:\n            if not os.path.isdir(os.path.dirname(config_file_path)):\n                os.makedirs(os.path.dirname(config_file_path), exist_ok=True) # pragma: no cover\n        except OSError as exc: # pragma: no cover\n            self.logger.exception(\"Could not create config folder!\")\n            raise  TOMLCreateConfigError(f\"unable to create config folder: ({os.path.dirname(config_file_path)})\") from exc # pragma: no cover\n        try:\n            self.logger.debug(\"Creating config\")\n            with Path(config_file_path).open(\"w\") as conf:\n                conf.write(tomlkit.dumps(self.defaults))\n        except OSError as exc: # pragma: no cover\n            self.logger.exception(\"Could not create config file!\")\n            raise TOMLCreateConfigError(f\"unable to create config file: ({config_file_path})\") from exc\n</code></pre>"},{"location":"configurator/#src.simple_toml_configurator.toml_configurator.Configuration.get_settings","title":"<code>get_settings()</code>","text":"<p>Get all config key values as a dictionary.</p> <p>Dict keys are formatted as: <code>table_key</code>:</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; defaults = {...}\n&gt;&gt;&gt; settings = Configuration()\n&gt;&gt;&gt; settings.init_config(\"config\", defaults, \"app_config\"))\n&gt;&gt;&gt; settings.get_settings()\n{'app_ip': '0.0.0.0', 'app_host': '', 'app_port': 5000, 'app_upload_folder': 'uploads'}\n</code></pre> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict[str, Any]: Dictionary with config key values.</p> Source code in <code>src/simple_toml_configurator/toml_configurator.py</code> <pre><code>def get_settings(self) -&gt; dict[str, Any]:\n    \"\"\"Get all config key values as a dictionary.\n\n    Dict keys are formatted as: `table_key`:\n\n    Examples:\n        ```pycon\n        &gt;&gt;&gt; defaults = {...}\n        &gt;&gt;&gt; settings = Configuration()\n        &gt;&gt;&gt; settings.init_config(\"config\", defaults, \"app_config\"))\n        &gt;&gt;&gt; settings.get_settings()\n        {'app_ip': '0.0.0.0', 'app_host': '', 'app_port': 5000, 'app_upload_folder': 'uploads'}\n        ```\n\n    Returns:\n        dict[str, Any]: Dictionary with config key values.\n    \"\"\"\n    settings: dict[str, Any] = {}\n    for table in self.config:\n        for key, value in self.config[table].items():\n            settings[f\"{table}_{key}\"] = value\n    return settings\n</code></pre>"},{"location":"configurator/#src.simple_toml_configurator.toml_configurator.Configuration.init_config","title":"<code>init_config(config_path, defaults, config_file_name='config', env_prefix='')</code>","text":"<p>Creates the config folder and toml file if needed.</p> <p>Upon init it will add any new/missing values/tables from <code>defaults</code> into the existing TOML config. Removes any old values/tables from <code>self.config</code> that are not in <code>self.defaults</code>.</p> <p>Sets all config keys as attributes on the class. e.g. <code>self.table.key</code>, <code>self.table_key</code> and <code>self._table_key</code></p> <p>Env variables of all config keys are set as uppercase. e.g. <code>APP_HOST</code> and <code>APP_PORT</code> or <code>APP_CONFIG_APP_HOST</code> and <code>APP_CONFIG_APP_PORT</code> if <code>env_prefix</code> is set to \"app_config\".</p> <p>Nested tables are set as nested environment variables. e.g. <code>APP_CONFIG_APP_DATABASES_PROD</code> and <code>APP_CONFIG_APP_DATABASES_DEV</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; settings = Configuration()\n&gt;&gt;&gt; settings.init_config(\"config\", defaults, \"app_config\"))\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>config_path</code> <code>str | Path</code> <p>Path to config folder</p> required <code>defaults</code> <code>dict[str, dict]</code> <p>Dictionary with all default values for your application</p> required <code>config_file_name</code> <code>str</code> <p>Name of the config file. Defaults to \"config\".</p> <code>'config'</code> <code>env_prefix</code> <code>str</code> <p>Prefix for environment variables. Defaults to \"\".</p> <code>''</code> <p>Returns:</p> Type Description <code>TOMLDocument</code> <p>dict[str,Any]: Returns a TOMLDocument.</p> Source code in <code>src/simple_toml_configurator/toml_configurator.py</code> <pre><code>def init_config(self, config_path:str|Path, defaults:dict[str,dict], config_file_name:str=\"config\",env_prefix:str=\"\") -&gt; TOMLDocument:\n    \"\"\"\n    Creates the config folder and toml file if needed.\n\n    Upon init it will add any new/missing values/tables from `defaults` into the existing TOML config.\n    Removes any old values/tables from `self.config` that are not in `self.defaults`.\n\n    Sets all config keys as attributes on the class. e.g. `self.table.key`, `self.table_key` and `self._table_key`\n\n    Env variables of all config keys are set as uppercase. e.g. `APP_HOST` and `APP_PORT` or `APP_CONFIG_APP_HOST` and `APP_CONFIG_APP_PORT` if `env_prefix` is set to \"app_config\".\n\n    Nested tables are set as nested environment variables. e.g. `APP_CONFIG_APP_DATABASES_PROD` and `APP_CONFIG_APP_DATABASES_DEV`.\n\n    Examples:\n        ```pycon\n        &gt;&gt;&gt; settings = Configuration()\n        &gt;&gt;&gt; settings.init_config(\"config\", defaults, \"app_config\"))\n        ```\n\n    Args:\n        config_path (str|Path): Path to config folder\n        defaults (dict[str,dict]): Dictionary with all default values for your application\n        config_file_name (str, optional): Name of the config file. Defaults to \"config\".\n        env_prefix (str, optional): Prefix for environment variables. Defaults to \"\".\n\n    Returns:\n        dict[str,Any]: Returns a TOMLDocument.\n    \"\"\"\n\n    if not isinstance(config_path, (str, Path)):\n        raise TypeError(f\"argument config_path must be of type {type(str)} or {type(Path)}, not: {type(config_path)}\") # pragma: no cover\n    if not isinstance(defaults, dict):\n        raise TypeError(f\"argument defaults must be of type {type(dict)}, not: {type(defaults)}\") # pragma: no cover\n    if not isinstance(env_prefix, str):\n        raise TypeError(f\"argument env_prefix must be of type {type(str)}, not: {type(env_prefix)}\") # pragma: no cover\n    if not isinstance(config_file_name, str):\n        raise TypeError(f\"argument config_file_name must be of type {type(str)}, not: {type(config_file_name)}\") # pragma: no cover\n\n    self.defaults:dict[str,dict] = defaults\n    self.config_path:str|Path = config_path\n    self.config_file_name:str = f\"{config_file_name}.toml\"\n    self.env_prefix:str = env_prefix\n    self._full_config_path:str = os.path.join(self.config_path, self.config_file_name)\n    self.config:TOMLDocument = self._load_config()\n    self._sync_config_values()\n    self._set_os_env()\n    self._set_attributes()\n    return self.config\n</code></pre>"},{"location":"configurator/#src.simple_toml_configurator.toml_configurator.Configuration.update","title":"<code>update()</code>","text":"<p>Write the current config to file.</p> <p>Examples: <pre><code>&gt;&gt;&gt; from simple_toml_configurator import Configuration\n&gt;&gt;&gt; settings = Configuration()\n&gt;&gt;&gt; defaults = {\"mysql\": {\"databases\": {\"prod\":\"prod_db1\", \"dev\":\"dev_db1\"}}}\n&gt;&gt;&gt; settings.init_config(\"config\", defaults, \"app_config\")\n&gt;&gt;&gt; settings.mysql.databases.prod = \"prod_db2\"\n&gt;&gt;&gt; settings.update()\n&gt;&gt;&gt; settings.config[\"mysql\"][\"databases\"][\"prod\"]\n'prod_db2'\n&gt;&gt;&gt; settings.config[\"mysql\"][\"databases\"][\"prod\"] = \"prod_db3\"\n&gt;&gt;&gt; settings.update()\n&gt;&gt;&gt; settings.mysql_databases[\"prod\"]\n'prod_db3'\n</code></pre></p> Source code in <code>src/simple_toml_configurator/toml_configurator.py</code> <pre><code>def update(self):\n    \"\"\"Write the current config to file.\n\n    Examples:\n    ```pycon\n    &gt;&gt;&gt; from simple_toml_configurator import Configuration\n    &gt;&gt;&gt; settings = Configuration()\n    &gt;&gt;&gt; defaults = {\"mysql\": {\"databases\": {\"prod\":\"prod_db1\", \"dev\":\"dev_db1\"}}}\n    &gt;&gt;&gt; settings.init_config(\"config\", defaults, \"app_config\")\n    &gt;&gt;&gt; settings.mysql.databases.prod = \"prod_db2\"\n    &gt;&gt;&gt; settings.update()\n    &gt;&gt;&gt; settings.config[\"mysql\"][\"databases\"][\"prod\"]\n    'prod_db2'\n    &gt;&gt;&gt; settings.config[\"mysql\"][\"databases\"][\"prod\"] = \"prod_db3\"\n    &gt;&gt;&gt; settings.update()\n    &gt;&gt;&gt; settings.mysql_databases[\"prod\"]\n    'prod_db3'\n    ```\n    \"\"\"\n    self._write_config_to_file()\n    self._set_attributes()\n</code></pre>"},{"location":"configurator/#src.simple_toml_configurator.toml_configurator.Configuration.update_config","title":"<code>update_config(settings)</code>","text":"<p>Update all config values from a dictionary, set new attribute values and write the config to file. Use the same format as <code>self.get_settings()</code> returns to update the config.</p> <p>Examples: <pre><code>&gt;&gt;&gt; defaults = {\"mysql\": {\"databases\": {\"prod\":\"prod_db1\", \"dev\":\"dev_db1\"}}}\n&gt;&gt;&gt; settings = Configuration()\n&gt;&gt;&gt; settings.init_config(\"config\", defaults, \"app_config\")\n&gt;&gt;&gt; settings.update_config({\"mysql_databases\": {\"prod\":\"prod_db1\", \"dev\":\"dev_db2\"}})\nprint(settings.mysql_databases[\"dev\"])\n'dev_db2'\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <code>dict</code> <p>Dict with key values</p> required Source code in <code>src/simple_toml_configurator/toml_configurator.py</code> <pre><code>def update_config(self, settings: dict[str,Any]) -&gt; None:\n    \"\"\"Update all config values from a dictionary, set new attribute values and write the config to file.\n    Use the same format as `self.get_settings()` returns to update the config.\n\n    Examples:\n    ```pycon\n    &gt;&gt;&gt; defaults = {\"mysql\": {\"databases\": {\"prod\":\"prod_db1\", \"dev\":\"dev_db1\"}}}\n    &gt;&gt;&gt; settings = Configuration()\n    &gt;&gt;&gt; settings.init_config(\"config\", defaults, \"app_config\")\n    &gt;&gt;&gt; settings.update_config({\"mysql_databases\": {\"prod\":\"prod_db1\", \"dev\":\"dev_db2\"}})\n    print(settings.mysql_databases[\"dev\"])\n    'dev_db2'\n    ```\n\n    Args:\n        settings (dict): Dict with key values\n    \"\"\"\n    if not isinstance(settings, dict):\n        raise TypeError(f\"Argument settings must be of type {type(dict)}, not: {type(settings)}\") # pragma: no cover\n    try:\n        for table in self.config:\n            for key, value in settings.items():\n                table_key = key.split(f\"{table}_\")[-1]\n                if self.config.get(table) and table_key in self.config[table].keys():\n                    if self.config[table][table_key] != value:\n                        self.logger.info(\"Updating TOML Document -&gt; Table: ('%s') Key: ('%s')\",table, table_key)\n                        self.config[table][table_key] = value\n    except Exception as exc: # pragma: no cover\n        self.logger.exception(\"Could not update config!\")\n        raise TOMLConfigUpdateError(\"unable to update config!\") from exc\n    self._write_config_to_file()\n    self._set_attributes()\n</code></pre>"},{"location":"exceptions/","title":"Exceptions","text":""},{"location":"exceptions/#src.simple_toml_configurator.exceptions.TOMLConfigFileNotFound","title":"<code>TOMLConfigFileNotFound</code>","text":"<p>             Bases: <code>TOMLConfiguratorException</code></p> <p>Raised when the TOML configuration file is not found.</p> Source code in <code>src/simple_toml_configurator/exceptions.py</code> <pre><code>class TOMLConfigFileNotFound(TOMLConfiguratorException):\n    \"\"\"Raised when the TOML configuration file is not found.\"\"\"\n    pass\n</code></pre>"},{"location":"exceptions/#src.simple_toml_configurator.exceptions.TOMLConfigUpdateError","title":"<code>TOMLConfigUpdateError</code>","text":"<p>             Bases: <code>TOMLConfiguratorException</code></p> <p>Raised when an error occurs while updating the TOML configuration file.</p> Source code in <code>src/simple_toml_configurator/exceptions.py</code> <pre><code>class TOMLConfigUpdateError(TOMLConfiguratorException):\n    \"\"\"Raised when an error occurs while updating the TOML configuration file.\"\"\"\n    pass\n</code></pre>"},{"location":"exceptions/#src.simple_toml_configurator.exceptions.TOMLConfiguratorException","title":"<code>TOMLConfiguratorException</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Base class for all exceptions raised by the TomlConfigurator class.</p> Source code in <code>src/simple_toml_configurator/exceptions.py</code> <pre><code>class TOMLConfiguratorException(Exception):\n    \"\"\"Base class for all exceptions raised by the TomlConfigurator class.\"\"\"\n    pass\n</code></pre>"},{"location":"exceptions/#src.simple_toml_configurator.exceptions.TOMLCreateConfigError","title":"<code>TOMLCreateConfigError</code>","text":"<p>             Bases: <code>TOMLConfiguratorException</code></p> <p>Raised when an error occurs while creating the TOML configuration file.</p> Source code in <code>src/simple_toml_configurator/exceptions.py</code> <pre><code>class TOMLCreateConfigError(TOMLConfiguratorException):\n    \"\"\"Raised when an error occurs while creating the TOML configuration file.\"\"\"\n    pass\n</code></pre>"},{"location":"exceptions/#src.simple_toml_configurator.exceptions.TOMLLoadConfigError","title":"<code>TOMLLoadConfigError</code>","text":"<p>             Bases: <code>TOMLConfiguratorException</code></p> <p>Raised when an error occurs while loading the TOML configuration file.</p> Source code in <code>src/simple_toml_configurator/exceptions.py</code> <pre><code>class  TOMLLoadConfigError(TOMLConfiguratorException):\n    \"\"\"Raised when an error occurs while loading the TOML configuration file.\"\"\"\n    pass\n</code></pre>"},{"location":"exceptions/#src.simple_toml_configurator.exceptions.TOMLWriteConfigError","title":"<code>TOMLWriteConfigError</code>","text":"<p>             Bases: <code>TOMLConfiguratorException</code></p> <p>Raised when an error occurs while writing the TOML configuration file.</p> Source code in <code>src/simple_toml_configurator/exceptions.py</code> <pre><code>class TOMLWriteConfigError(TOMLConfiguratorException):\n    \"\"\"Raised when an error occurs while writing the TOML configuration file.\"\"\"\n    pass\n</code></pre>"},{"location":"flask-custom-example/","title":"Custom Flask Example","text":"<p>The <code>Configuration</code> class can be extended and customized to cater to application-specific requirements. Developers can implement custom logic with getters and setters to handle unique settings or scenarios.</p>"},{"location":"flask-custom-example/#folder-contents","title":"Folder contents","text":"<pre><code>\u251c\u2500\u2500 __init__.py\n\u251c\u2500\u2500 app.py\n\u251c\u2500\u2500 utils.py\n\u2514\u2500\u2500 extensions\n    \u2514\u2500\u2500 config.py\n</code></pre> <p>This example uses a custom Configuration class in the config.py module that inherits from <code>Configuration</code>.</p> CustomConfiguration <pre><code>class CustomConfiguration(Configuration):\n    def __init__(self):\n        super().__init__()\n\n    @property\n    def logging_debug(self):\n        return getattr(self, \"_logging_debug\")\n\n    @logging_debug.setter\n    def logging_debug(self, value: bool):\n        if not isinstance(value, bool):\n            raise ValueError(f\"value must be of type bool not {type(value)}\")\n        self._logging_debug = value\n        log_level = \"DEBUG\" if value else \"INFO\"\n        configure_logging(log_level)\n</code></pre> <p>The custom class uses a property with a setter that executes the <code>configure_logging</code> function from <code>utils.py</code> whenever the logging_debug attribute is updated. Thus setting the log level to \"DEBUG\" if the value is True.</p> <p>This will change the log level on you Flask app without restarting it.</p>"},{"location":"flask-custom-example/#code-examples","title":"Code examples","text":"extensions/config.py config.py<pre><code>import logging\nimport os\nfrom binascii import hexlify\nfrom simple_toml_configurator import Configuration\nfrom utils import configure_logging\n\nlogger = logging.getLogger(__name__)\n\ndefault_config = {\n    \"app\": {\n        \"ip\": \"0.0.0.0\",\n        \"host\": \"\",\n        \"port\": 5000,\n        \"upload_folder\": \"uploads\",\n        \"flask_secret_key\": \"\",\n        \"proxy\": \"\",\n        \"site_url\": \"http://localhost:5000\",\n        \"debug\": True,\n        },\n    \"mysql\": {\n        \"host\": \"\",\n        \"port\": \"\",\n        \"user\": \"\",\n        \"password\": \"\",\n        \"databases\": {\"prod\":\"test\", \"dev\":\"test2\"},\n        },\n    \"scheduler\": {\n        \"disabled\": True\n        },\n    \"logging\": {\n        \"debug\": True\n        },\n    \"queue\": {\n        \"disabled\": True\n        },\n    }\n\nconfig_path = os.environ.get(\"CONFIG_PATH\", os.path.join(os.getcwd(), \"config\"))\n\nclass CustomConfiguration(Configuration):\n    def __init__(self):\n        super().__init__()\n\n    @property\n    def logging_debug(self):\n        return getattr(self, \"_logging_debug\")\n\n    @logging_debug.setter\n    def logging_debug(self, value: bool):\n        if not isinstance(value, bool):\n            raise ValueError(f\"value must be of type bool not {type(value)}\")\n        self._logging_debug = value\n        log_level = \"DEBUG\" if value else \"INFO\"\n        configure_logging(log_level)\n\nsettings = CustomConfiguration()\nsettings.init_config(config_path, default_config)\n\n# create random Flask secret_key if there's none in config.toml\nif not settings.config.get(\"app\", {}).get(\"flask_secret_key\"):\n    key = os.environ.get(\"APP_FLASK_SECRET_KEY\", hexlify(os.urandom(16)).decode())\n    settings.update_config({\"app_flask_secret_key\": key})\n\n# Set default mysql host\nif not settings.config.get(\"mysql\",{}).get(\"host\"):\n    mysql_host = os.environ.get(\"MYSQL_HOST\", \"localhost\")\n    settings.update_config({\"mysql_host\": mysql_host})\n\n# Set default mysql port\nif not settings.config.get(\"mysql\",{}).get(\"port\"):\n    mysql_port = os.environ.get(\"MYSQL_PORT\", \"3306\")\n    settings.update_config({\"mysql_port\": mysql_port})\n\n# Set default mysql user\nif not settings.config.get(\"mysql\",{}).get(\"user\"):\n    mysql_user = os.environ.get(\"MYSQL_USER\", \"root\")\n    settings.update_config({\"mysql_user\": mysql_user})\n\n# Set default mysql password\nif not settings.config.get(\"mysql\",{}).get(\"password\"):\n    mysql_password = os.environ.get(\"MYSQL_PASSWORD\", \"root\")\n    settings.update_config({\"mysql_password\": mysql_password})\n\nif not settings.config.get(\"mysql\",{}).get(\"database\"):\n    mysql_database = os.environ.get(\"MYSQL_DATABASE\", \"some_database\")\n    settings.update_config({\"mysql_database\": mysql_database})\n</code></pre> utils.py utils.py<pre><code>import logging\n# simple logger function that takes log_level as argument and sets the log level\nlogging.basicConfig(level=logging.INFO, format=\"%(asctime)s - %(levelname)s - %(message)s\")\nlogger = logging.getLogger()\n\ndef configure_logging(log_level: str) -&gt; None:\n    \"\"\"Configure logging for the application\n\n    Args:\n        log_level (str): Log level to set\n    \"\"\"\n    if logger.getEffectiveLevel() == logging.getLevelName(log_level):\n        return\n    logger.setLevel(log_level)\n    if log_level==\"DEBUG\":\n        logger.debug(f\"Debug logging enabled\")\n</code></pre> <p>app.py</p> app.py<pre><code>from flask import Flask, jsonify, request, url_for,redirect\nfrom extensions.config import settings\nimport logging\n\nlogger = logging.getLogger(__name__)\n\ndef create_app():\n    app = Flask(__name__)\n    app.config[\"SECRET_KEY\"] = settings.config.get(\"app\").get(\"flask_secret_key\")\n    app.config['APP_PORT'] = settings.config.get(\"app\").get(\"port\")\n    app.config['APP_IP'] = settings.config.get(\"app\").get(\"ip\")\n    app.config['APP_HOST'] = settings.config.get(\"app\").get(\"host\")\n    app.config[\"DEBUG\"] = settings.config.get(\"app\").get(\"debug\")\n    return app\n\napp = create_app()\n\n# simple route that returns the config\n@app.route(\"/\")\ndef app_settings():\n    return jsonify(\n        {\n        \"response\":  {\n            \"data\": {\n                \"configuration\": settings.get_settings(),\n                \"toml_config\": settings.config,\n            }\n        }\n        })\n\n# Update settings route\n@app.route(\"/update\", methods=[\"POST\"])\ndef update_settings():\n    \"\"\"Update settings route\"\"\"\n    data = request.get_json() # {\"logging_debug\": True, \"app_debug\": True}\n    settings.update_config(data)\n    return redirect(url_for(\"app_settings\"))\n\n# Get settings value route\n@app.route(\"/logger\", methods=[\"GET\"])\ndef get_settings():\n    \"\"\"Sets logging_debug to True or False\"\"\"\n    value = False if settings.logging_debug else True\n    settings.update_config({\"logging_debug\": value})\n    return jsonify({\"debug_logging\": settings.logging_debug})\n\nif __name__ == \"__main__\":\n    app.run(port=app.config.get(\"APP_PORT\"), host=app.config.get(\"APP_IP\"), debug=app.config.get(\"APP_DEBUG\"))\n</code></pre>"},{"location":"flask-simple-example/","title":"Simple Flask Example","text":""},{"location":"flask-simple-example/#folder-contents","title":"Folder contents","text":"<pre><code>\u251c\u2500\u2500 __init__.py\n\u251c\u2500\u2500 app.py\n\u2514\u2500\u2500 extensions\n    \u2514\u2500\u2500 config.py\n</code></pre> <p>This is a simple example using flask showing how to update the TOML configuration </p>"},{"location":"flask-simple-example/#code-examples","title":"Code examples","text":"extensions/config.py config.py<pre><code>import os\nfrom binascii import hexlify\nfrom simple_toml_configurator import Configuration\n\ndefault_config = {\n    \"app\": {\n        \"ip\": \"0.0.0.0\",\n        \"host\": \"\",\n        \"port\": 5000,\n        \"upload_folder\": \"uploads\",\n        \"flask_secret_key\": \"\",\n        \"proxy\": \"\",\n        \"site_url\": \"http://localhost:5000\",\n        \"debug\": True,\n        },\n    \"mysql\": {\n        \"host\": \"\",\n        \"port\": \"\",\n        \"user\": \"\",\n        \"password\": \"\",\n        \"databases\": {\"prod\":\"test\", \"dev\":\"test2\"},\n        },\n    \"scheduler\": {\n        \"disabled\": True\n        },\n    \"logging\": {\n        \"debug\": True\n        },\n    \"queue\": {\n        \"disabled\": True\n        },\n    }\n\nconfig_path = os.environ.get(\"CONFIG_PATH\", os.path.join(os.getcwd(), \"config\"))\nsettings = Configuration()\nsettings.init_config(config_path, default_config)\n\n# create random Flask secret_key if there's none in config.toml\nif not settings.config.get(\"app\", {}).get(\"flask_secret_key\"):\n    key = os.environ.get(\"APP_FLASK_SECRET_KEY\", hexlify(os.urandom(16)).decode())\n    settings.update_config({\"app_flask_secret_key\": key})\n\n# Set default mysql host\nif not settings.config.get(\"mysql\",{}).get(\"host\"):\n    mysql_host = os.environ.get(\"MYSQL_HOST\", \"localhost\")\n    settings.update_config({\"mysql_host\": mysql_host})\n\n# Set default mysql port\nif not settings.config.get(\"mysql\",{}).get(\"port\"):\n    mysql_port = os.environ.get(\"MYSQL_PORT\", \"3306\")\n    settings.update_config({\"mysql_port\": mysql_port})\n\n# Set default mysql user\nif not settings.config.get(\"mysql\",{}).get(\"user\"):\n    mysql_user = os.environ.get(\"MYSQL_USER\", \"root\")\n    settings.update_config({\"mysql_user\": mysql_user})\n\n# Set default mysql password\nif not settings.config.get(\"mysql\",{}).get(\"password\"):\n    mysql_password = os.environ.get(\"MYSQL_PASSWORD\", \"root\")\n    settings.update_config({\"mysql_password\": mysql_password})\n\nif not settings.config.get(\"mysql\",{}).get(\"database\"):\n    mysql_database = os.environ.get(\"MYSQL_DATABASE\", \"some_database\")\n    settings.update_config({\"mysql_database\": mysql_database})\n</code></pre> <p>app.py</p> app.py<pre><code>from flask import Flask, jsonify, request, url_for,redirect\nfrom extenstions.config import settings\n\ndef create_app():\n    app = Flask(__name__)\n    app.config[\"SECRET_KEY\"] = settings.config.get(\"app\").get(\"flask_secret_key\")\n    app.config['APP_PORT'] = settings.config.get(\"app\").get(\"port\")\n    app.config['APP_IP'] = settings.config.get(\"app\").get(\"ip\")\n    app.config['APP_HOST'] = settings.config.get(\"app\").get(\"host\")\n    app.config[\"DEBUG\"] = settings.config.get(\"app\").get(\"debug\")\n    return app\n\napp = create_app()\n\n# simple route that returns the config\n@app.route(\"/\")\ndef app_settings():\n    return jsonify(\n        {\n        \"response\":  {\n            \"data\": {\n                \"configuration\": settings.get_settings(),\n            }\n            }\n        })\n\n# Update settings route\n@app.route(\"/update\", methods=[\"POST\"])\ndef update_settings():\n    data = request.get_json() # {\"app_proxy\": \"http://localhost:8080\", \"app_debug\": \"True}\n    settings.update_config(data)\n    return redirect(url_for(\"app_settings\"))\n\n# Get settings value route\n@app.route(\"/get\", methods=[\"GET\"])\ndef get_settings():\n    key = request.args.get(\"key\",\"\")\n    value = request.args.get(\"value\",\"\")\n    config_attr_value = settings.config.get(key, {}).get(value, \"not found\")\n    instance_attr_value = getattr(settings, key, \"not found\")\n    return jsonify(\n        {\n        \"response\":  {\n            \"data\": {\n                \"Configuration.config\": {\n                \"key\": key,\n                \"value\": config_attr_value,\n                },\n                \"Configuration\": {\n                \"key\": key,\n                \"value\": instance_attr_value,\n                },\n            }\n            }\n        })\n\nif __name__ == \"__main__\":\n    app.run(port=app.config.get(\"APP_PORT\"), host=app.config.get(\"APP_IP\"), debug=app.config.get(\"APP_DEBUG\"))\n</code></pre>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#installation","title":"Installation","text":"<p>To use the Simple TOML Configurator in your Python projects, you can install it using the <code>pip</code> package manager. The package is available on PyPI (Python Package Index).</p>"},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<p>Before installing, make sure you have Python and <code>pip</code> installed on your system. You can check if <code>pip</code> is installed by running:</p> <pre><code>pip --version\n</code></pre> <p>If <code>pip</code> is not installed, follow the official <code>pip</code> installation guide to get it set up.</p>"},{"location":"installation/#installation-steps","title":"Installation Steps","text":"<p>To install the Simple TOML Configurator package, open your terminal or command prompt and run the following command:</p> <pre><code>pip install simple-toml-configurator\n</code></pre> <p>This command will download and install the package along with its dependencies. After the installation is complete, you can start using the package in your Python projects.</p> <p>See Usage or Examples for more information on how to use the package.</p>"},{"location":"usage-examples/","title":"Usage","text":""},{"location":"usage-examples/#usage-examples","title":"Usage Examples","text":""},{"location":"usage-examples/#initializing-configuration","title":"Initializing Configuration","text":"<p>To get started with the Simple TOML Configurator, you need to initialize the configuration settings using the <code>init_config</code> method or init <code>Configuration</code> object with the arguments. This sets up the default values and configuration file paths.</p> <pre><code>from simple_toml_configurator import Configuration\n\n# Define default configuration values\ndefault_config = {\n    \"app\": {\n        \"ip\": \"0.0.0.0\",\n        \"host\": \"\",\n        \"port\": 5000,\n        \"upload_folder\": \"uploads\"\n    },\n    \"mysql\": {\n        \"databases\": {\n            \"prod\": \"db1\",\n            \"dev\": \"db2\"\n        }\n    }\n}\n\n# Initialize the Simple TOML Configurator\nsettings = Configuration()\nsettings.init_config(\"config\", default_config, \"app_config\")\n</code></pre>"},{"location":"usage-examples/#load-defaults-from-a-toml-file","title":"Load defaults from a TOML file","text":"<pre><code>from simple_toml_configurator import Configuration\nimport tomlkit\nimport os\nfrom pathlib import Path\n\ndefault_file_path = Path(os.path.join(os.getcwd(), \"default.toml\"))\ndefaults = tomlkit.loads(file_path.read_text())\nsettings = Configuration(\"config\", defaults, \"app_config\")\n</code></pre>"},{"location":"usage-examples/#accessing-configuration-values","title":"Accessing Configuration Values","text":"<p>You can access configuration values as attributes of the <code>Configuration</code> instance. This attribute-based access makes it straightforward to retrieve settings. There are two main ways to access configuration values:</p> <ol> <li> <p>Attribute access:</p> <ul> <li>This is the default access method. ex: <code>settings.app.ip</code></li> </ul> </li> <li> <p>Table prefix access:</p> <ul> <li>Add the table name as a prefix to the key name. ex: <code>settings.app_ip</code> instead of <code>settings.app.ip</code>. This only works for the first level of nesting.</li> </ul> </li> </ol> <p>Info</p> <p>If the table contains a nested table, you can access the nested table using the same syntax. ex: <code>settings.mysql.databases.prod</code></p> <p>Note</p> <p>This works for any level of nesting.</p>"},{"location":"usage-examples/#environment-variable-access","title":"Environment variable access","text":"<p>Access the configuration values as environment variables. ex: <code>APP_IP</code> instead of <code>settings.app.ip</code>.</p> <p>Or <code>APP_CONFIG_APP_IP</code> if <code>env_prefix</code> is set to \"app_config\".</p> <p>You can also access nested values. ex: <code>MYSQL_DATABASES_PROD</code>.</p> <p>Note</p> <p>This works for any level of nesting.</p>"},{"location":"usage-examples/#updating-configuration-settings","title":"Updating Configuration Settings","text":"<p>Use the <code>update_config</code> or <code>update</code> method to modify values while ensuring consistency across instances.</p>"},{"location":"usage-examples/#update-method","title":"update() method","text":"<pre><code># Update the ip key in the app table\nsettings.app.ip = \"1.2.3.4\"\nsettings.update()\n</code></pre>"},{"location":"usage-examples/#update_config-method","title":"update_config() method","text":"<pre><code># Update the ip key in the app table\nsettings.update_config({\"app_ip\": \"1.2.3.4\"})\n</code></pre>"},{"location":"usage-examples/#update-the-config-dictionary-directly","title":"Update the config dictionary directly","text":"<p>You can directly modify configuration values within the <code>config</code> dictionary. After making changes, use the <code>update</code> method to write the updated configuration to the file.</p> <pre><code># Modify values directly and update configuration\nsettings.config[\"app\"][\"ip\"] = \"0.0.0.0\"\nsettings.update()\n</code></pre>"},{"location":"usage-examples/#accessing-all-settings","title":"Accessing All Settings","text":"<p>Retrieve all configuration settings as a dictionary using the <code>get_settings</code> method. This provides an overview of all configured values.</p> <pre><code># Get all configuration settings\nall_settings = settings.get_settings()\nprint(all_settings) # Output: {'app_ip': '1.2.3.4', 'app_host': '', 'app_port': 5000, 'app_upload_folder': 'uploads'}\n</code></pre>"},{"location":"usage-examples/#customization-with-inheritance","title":"Customization with Inheritance","text":"<p>For advanced use cases, you can create a custom configuration class by inheriting from <code>Configuration</code>. This allows you to add custom logic and properties tailored to your application.</p> <pre><code>from simple_toml_configurator import Configuration\n\nclass CustomConfiguration(Configuration):\n    def __init__(self):\n        super().__init__()\n\n    # Add custom properties with getters and setters\n    @property\n    def custom_setting(self):\n        return getattr(self, \"_custom_setting\")\n\n    @custom_setting.setter\n    def custom_setting(self, value):\n        # Custom logic for updating custom_setting\n        self._custom_setting = value\n        # Additional actions can be performed here\n\n# Initialize and use the custom configuration\ncustom_settings = CustomConfiguration()\ncustom_settings.init_config(\"config\", default_config, \"custom_config\")\n</code></pre>"}]}